<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Komodi</title>
    <style>* {padding: 0; margin: 0}</style>
</head>
<script src="pixi.js/bin/pixi.js"></script>
<body>
<script type="text/javascript">
    //Create the renderer
    let renderer = PIXI.autoDetectRenderer(
        1, 1,
        {antialias: true, transparent: false, resolution: 1}
    );

    renderer.backgroundColor = 0xecf0f1;
    renderer.view.style.position = "absolute";
    renderer.view.style.display = "block";
    renderer.autoResize = true;

    //Add the canvas to the HTML document
    document.body.appendChild(renderer.view);

    let stage = new PIXI.Container();

    let menu = new PIXI.Graphics();

    function hitTestRectangle(r1, r2) {
        //Define the variables we'll need to calculate
        let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

        //hit will determine whether there's a collision
        hit = false;

        //Find the center points of each sprite
        r1.centerX = r1.x + r1.width / 2;
        r1.centerY = r1.y + r1.height / 2;
        r2.centerX = r2.x + r2.width / 2;
        r2.centerY = r2.y + r2.height / 2;

        //Find the half-widths and half-heights of each sprite
        r1.halfWidth = r1.width / 2;
        r1.halfHeight = r1.height / 2;
        r2.halfWidth = r2.width / 2;
        r2.halfHeight = r2.height / 2;

        //Calculate the distance vector between the sprites
        vx = r1.centerX - r2.centerX;
        vy = r1.centerY - r2.centerY;

        //Figure out the combined half-widths and half-heights
        combinedHalfWidths = r1.halfWidth + r2.halfWidth;
        combinedHalfHeights = r1.halfHeight + r2.halfHeight;

        if (Math.abs(vx) < combinedHalfWidths) {
            hit = Math.abs(vy) < combinedHalfHeights
        } else {
            hit = false;
        }

        return hit;
    }

    class BubbleShape extends PIXI.Graphics {
        constructor(color, highlighted) {
            super();

            const BUBBLE_WIDTH = 100;
            const BUBBLE_HEIGHT = 60;
            const TRIANGLE_WIDTH = 20;
            const TRIANGLE_HEIGHT = 15;

            const left = -BUBBLE_WIDTH*.5;
            const top = -BUBBLE_HEIGHT*.5;
            const right = -left;
            const bottom = -top;

            let path = [
                left, top,
                -TRIANGLE_WIDTH*.5, top,
                0, top+TRIANGLE_HEIGHT,
                TRIANGLE_WIDTH*.5, top,
                right, top,
                right, bottom,
                TRIANGLE_WIDTH*.5, bottom,
                0, bottom+TRIANGLE_HEIGHT,
                -TRIANGLE_WIDTH*.5, bottom,
                left, bottom,
                left, top,
            ];

            this.beginFill(color);
            this.drawPolygon(path);
            this.endFill(color);

            if (highlighted) {
                this.lineStyle(4, 0xFF0000, 1);
                this.moveTo(path[0], path[1])
                for (let i = 1; i <= 4; i++) {
                    this.lineTo(path[i*2], path[i*2+1]);
                }
            }
        }
    }

    let BUBBLE_HIT = new PIXI.Rectangle(-50, -30, 100, 60);

    let dragging = null;

    class Block extends PIXI.Container {
        constructor(color) {
            super();

            this._color = color;
            this._highlight = false;

            this._normalShape = new BubbleShape(color, false);
            this._highlightShape = new BubbleShape(color, true);

            this._currentShape = this._normalShape;
            this.addChild(this._currentShape);

            this.interactive = true;
            this.hitArea = BUBBLE_HIT;

            this.mousedown = () => {
                dragging = this;
            };

            this.mouseup = () => {
                if (hitTestRectangle(this, menu)) {
                    this.parent.removeChild(this);
                }
                dragging = null;
            };
        }

        get highlight() {
            return this._highlight;
        }

        set highlight(highlighted) {
            this._highlight = highlighted;

            this.removeChild(this._currentShape);
            this._currentShape = highlighted ? this._highlightShape : this._normalShape;
            this.addChild(this._currentShape);
        }
    }

    class BlockGenerator extends PIXI.Container {
        constructor(color) {
            super();

            this._color = color;
            this._highlight = false;

            this.addChild(new BubbleShape(color, false));

            this.interactive = true;
            this.buttonMode = true;
            this.hitArea = BUBBLE_HIT;

            this.mouseover = () => this.alpha = 0.7;
            this.mouseout = () => this.alpha = 1;

            this.mousedown = () => {
                let block = new Block(this._color);
                dragging = block;
                stage.addChild(block);
            }
        }
    }

    stage.addChild(menu);

    let purpleBubble = new BlockGenerator(0x9b59b6);
    purpleBubble.x = 80;
    purpleBubble.y = 55;

    let orangeBubble = new BlockGenerator(0xe67e22);
    orangeBubble.x = 220;
    orangeBubble.y = 55;

    menu.addChild(purpleBubble);
    menu.addChild(orangeBubble);

    function resizeWindow() {
        const MENU_HEIGHT = 120;

        renderer.resize(window.innerWidth, window.innerHeight);

        menu.clear();
        menu.beginFill(0xbdc3c7);
        menu.drawRect(0, 0, window.innerWidth, MENU_HEIGHT);
        menu.endFill();
    }

    window.addEventListener('resize', resizeWindow, true);
    resizeWindow();

    function gameLoop() {
        requestAnimationFrame(gameLoop);

        if (dragging) {
            dragging.position = renderer.plugins.interaction.mouse.global;
            console.log(dragging.position);
        }

        renderer.render(stage);
    }

    renderer.render(stage);
    gameLoop();
</script>
</body>
</html>