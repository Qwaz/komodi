<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Komodi</title>
    <style>* {padding: 0; margin: 0}</style>
</head>
<script src="pixi.js/bin/pixi.js"></script>
<body>
<script type="text/javascript">
    function hitTestRectangle(r1, r2) {
        //Define the variables we'll need to calculate
        let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

        //hit will determine whether there's a collision
        hit = false;

        //Find the center points of each sprite
        r1.centerX = r1.x + r1.width / 2;
        r1.centerY = r1.y + r1.height / 2;
        r2.centerX = r2.x + r2.width / 2;
        r2.centerY = r2.y + r2.height / 2;

        //Find the half-widths and half-heights of each sprite
        r1.halfWidth = r1.width / 2;
        r1.halfHeight = r1.height / 2;
        r2.halfWidth = r2.width / 2;
        r2.halfHeight = r2.height / 2;

        //Calculate the distance vector between the sprites
        vx = r1.centerX - r2.centerX;
        vy = r1.centerY - r2.centerY;

        //Figure out the combined half-widths and half-heights
        combinedHalfWidths = r1.halfWidth + r2.halfWidth;
        combinedHalfHeights = r1.halfHeight + r2.halfHeight;

        if (Math.abs(vx) < combinedHalfWidths) {
            hit = Math.abs(vy) < combinedHalfHeights
        } else {
            hit = false;
        }

        return hit;
    }

    const BUBBLE_WIDTH = 100;
    const BUBBLE_HEIGHT = 60;
    const TRIANGLE_WIDTH = 20;
    const TRIANGLE_HEIGHT = 15;

    class BubbleShape extends PIXI.Graphics {
        constructor(color, highlighted) {
            super();

            const left = -BUBBLE_WIDTH*.5;
            const top = -BUBBLE_HEIGHT*.5;
            const right = -left;
            const bottom = -top;

            let path = [
                left, top,
                -TRIANGLE_WIDTH*.5, top,
                0, top+TRIANGLE_HEIGHT,
                TRIANGLE_WIDTH*.5, top,
                right, top,
                right, bottom,
                TRIANGLE_WIDTH*.5, bottom,
                0, bottom+TRIANGLE_HEIGHT,
                -TRIANGLE_WIDTH*.5, bottom,
                left, bottom,
                left, top,
            ];

            this.lineStyle(1, 0x000000, 1);
            this.beginFill(color);
            this.drawPolygon(path);
            this.endFill(color);

            if (highlighted) {
                this.lineStyle(4, 0xFF0000, 1);
                this.moveTo(path[0], path[1]);
                for (let i = 1; i <= 4; i++) {
                    this.lineTo(path[i*2], path[i*2+1]);
                }
            }
        }
    }

    //Create the renderer
    let renderer = PIXI.autoDetectRenderer(
        1, 1,
        {antialias: true, transparent: false, resolution: 1}
    );

    renderer.backgroundColor = 0xecf0f1;
    renderer.view.style.position = "absolute";
    renderer.view.style.display = "block";
    renderer.autoResize = true;

    //Add the canvas to the HTML document
    document.body.appendChild(renderer.view);

    let stage = new PIXI.Container();

    let menu = new PIXI.Graphics();

    let freeBlocks = new Set();

    let BUBBLE_HIT = new PIXI.Rectangle(-BUBBLE_WIDTH*.5, -BUBBLE_HEIGHT*.5, BUBBLE_WIDTH, BUBBLE_HEIGHT);

    let dragging = null;

    class Block extends PIXI.Container {
        constructor(color) {
            super();
            dragging = this;
            freeBlocks.add(this);

            this._color = color;
            this._highlight = false;
            this._prevBlock = null;
            this._nextBlock = null;

            this._normalShape = new BubbleShape(color, false);
            this._highlightShape = new BubbleShape(color, true);

            this._currentShape = this._normalShape;
            this.addChild(this._currentShape);

            this.interactive = true;
            this.buttonMode = true;
            this.hitArea = BUBBLE_HIT;

            this.mouseover = () => this.alpha = 0.7;
            this.mouseout = () => this.alpha = 1;

            this.mousedown = () => {
                dragging = this;

                if (this._prevBlock) {
                    freeBlocks.add(this._prevBlock);
                    this._prevBlock._nextBlock = null;
                    this._prevBlock = null;
                }
            };

            this.mouseup = () => {
                if (hitTestRectangle(this, menu)) {
                    this.deleteTree();
                } else {
                    freeBlocks.forEach((block) => {
                        if (!this._prevBlock && block.possibleNextBlock(this)) {
                            this._prevBlock = block;
                            block._nextBlock = this;
                            block.highlight = false;
                            freeBlocks.delete(block);

                            block.adjustChildrenPosition();
                        }
                    });
                }
                dragging = null;
            };
        }

        get highlight() {
            return this._highlight;
        }

        set highlight(highlighted) {
            this._highlight = highlighted;

            this.removeChild(this._currentShape);
            this._currentShape = highlighted ? this._highlightShape : this._normalShape;
            this.addChild(this._currentShape);
        }

        possibleNextBlock(block) {
            let NEAR = 40;

            return Math.abs(block.x - this.x) <= NEAR
                && Math.abs(block.y - (this.y - BUBBLE_HEIGHT)) <= NEAR;
        }

        deleteTree() {
            if (freeBlocks.has(this)) {
                freeBlocks.delete(this);
            }
            this.parent.removeChild(this);
            if (this._nextBlock) {
                this._nextBlock.deleteTree();
            }
        }

        adjustChildrenPosition() {
            if (this._nextBlock) {
                this._nextBlock.x = this.x;
                this._nextBlock.y = this.y - BUBBLE_HEIGHT;
                this._nextBlock.adjustChildrenPosition();
            }
        }
    }

    class BlockGenerator extends PIXI.Container {
        constructor(color) {
            super();

            this._color = color;
            this._highlight = false;

            this.addChild(new BubbleShape(color, false));

            this.interactive = true;
            this.buttonMode = true;
            this.hitArea = BUBBLE_HIT;

            this.mouseover = () => this.alpha = 0.7;
            this.mouseout = () => this.alpha = 1;

            this.mousedown = () => {
                let block = new Block(this._color);
                stage.addChild(block);
            }
        }
    }

    stage.addChild(menu);

    let purpleBubble = new BlockGenerator(0x9b59b6);
    purpleBubble.x = 80;
    purpleBubble.y = 55;

    let orangeBubble = new BlockGenerator(0xe67e22);
    orangeBubble.x = 220;
    orangeBubble.y = 55;

    menu.addChild(purpleBubble);
    menu.addChild(orangeBubble);

    function resizeWindow() {
        const MENU_HEIGHT = 120;

        renderer.resize(window.innerWidth, window.innerHeight);

        menu.clear();
        menu.beginFill(0xbdc3c7);
        menu.drawRect(0, 0, window.innerWidth, MENU_HEIGHT);
        menu.endFill();
    }

    window.addEventListener('resize', resizeWindow, true);
    resizeWindow();

    function gameLoop() {
        requestAnimationFrame(gameLoop);

        if (dragging) {
            dragging.position = renderer.plugins.interaction.mouse.global;
            dragging.adjustChildrenPosition();

            freeBlocks.forEach((block) => {
                block.highlight = block.possibleNextBlock(dragging);
            });
        }

        renderer.render(stage);
    }

    renderer.render(stage);
    gameLoop();
</script>
</body>
</html>